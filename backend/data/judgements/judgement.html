<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Size Ablation Judgement</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; }
      header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px; }
      .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      .fileinfo { font-weight: 600; }
      .grid { margin-top: 16px; display: grid; grid-template-columns: repeat(1, minmax(0, 1fr)); gap: 12px; }
      @media (min-width: 900px) { .grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
      .post { border: 1px solid #e5e5e5; border-radius: 8px; padding: 12px; }
      .title { font-weight: 600; margin-bottom: 6px; }
      .meta { color: #666; font-size: 12px; margin-bottom: 6px; }
      .self { white-space: pre-wrap; }
      .row { display: flex; gap: 8px; align-items: center; }
      .sticky { position: sticky; top: 0; background: #fff; padding: 8px 0; z-index: 1; border-bottom: 1px solid #eee; }
      input[type="number"] { width: 80px; }
    </style>
  </head>
  <body>
    <header>
      <div>
        <div class="fileinfo" id="fileinfo">No file loaded</div>
        <div class="row sticky">
          <div>Adherence %: <span id="adhPct">0</span></div>
          <div>Coherence %: <span id="cohPct">0</span></div>
          <span id="status"></span>
        </div>
      </div>
      <div class="controls">
        <label>Provider <select id="provider"></select></label>
        <label>Model <select id="model"></select></label>
        <label>Topic <select id="topic"></select></label>
        <button id="loadMixed">Load Posts</button>
        <button id="prevBatch">Back 10</button>
        <button id="nextBatch">Next 10</button>
      </div>
    </header>

    <div class="grid" id="posts"></div>

    <script>
      const API_LIST = '/judgement/api/files';
      const API_FILE = '/judgement/api/file';
      const API_OPTIONS = '/judgement/api/options';
      const API_MIXED = '/judgement/api/mixed';
      const API_UPDATE = '/judgement/api/update';

      const fileinfoEl = document.getElementById('fileinfo');
      const providerEl = document.getElementById('provider');
      const modelEl = document.getElementById('model');
      const topicEl = document.getElementById('topic');
      const postsEl = document.getElementById('posts');
      const adhPctEl = document.getElementById('adhPct');
      const cohPctEl = document.getElementById('cohPct');
      const statusEl = document.getElementById('status');

      let files = [];
      let currentIndex = -1;
      let currentPath = '';
      let currentMixed = [];
      const BATCH_SIZE = 10;
      let pageIndex = 0; // 0-based batch index
      const stateByPost = new Map(); // key => { adh: boolean, coh: boolean, file: string }

      function makeKey(file, localIndex) {
        return `${file || ''}#${String(localIndex)}`;
      }

      // Track which posts have already been counted as "shown" to avoid double counting
      const shownKeys = new Set();

      function escapeHtml(str) {
        return (str || '').replace(/[&<>"']/g, (c) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[c]));
      }

      async function loadFiles() {
        const res = await fetch(API_LIST);
        const data = await res.json();
        files = data.files || [];
        // nothing to render; mixed mode UI replaces direct file selection
      }

      async function loadOptions() {
        const res = await fetch(API_OPTIONS);
        const data = await res.json();
        const options = data.options || [];
        const providers = [...new Set(options.map(o => o.provider))];
        providerEl.innerHTML = providers.map(p => `<option value="${p}">${p}</option>`).join('');
        function updateModels() {
          const selP = providerEl.value;
          const models = [...new Set(options.filter(o => o.provider === selP).map(o => o.model))];
          modelEl.innerHTML = models.map(m => `<option value="${m}">${m}</option>`).join('');
          updateTopics();
        }
        function updateTopics() {
          const selP = providerEl.value;
          const selM = modelEl.value;
          const topics = [...new Set(options.filter(o => o.provider === selP && o.model === selM).map(o => o.topic))];
          topicEl.innerHTML = topics.map(t => `<option value="${t}">${t}</option>`).join('');
        }
        providerEl.addEventListener('change', updateModels);
        modelEl.addEventListener('change', updateTopics);
        updateModels();
      }

      async function loadMixed() {
        const provider = providerEl.value;
        const model = modelEl.value;
        const topic = topicEl.value;
        fileinfoEl.textContent = `${provider} / ${model} / ${topic}`;
        statusEl.textContent = '';
        const res = await fetch(`${API_MIXED}?provider=${encodeURIComponent(provider)}&model=${encodeURIComponent(model)}&topic=${encodeURIComponent(topic)}`);
        const data = await res.json();
        currentMixed = data.posts || [];
        stateByPost.clear();
        shownKeys.clear();
        pageIndex = 0;
        showBatch(pageIndex);
      }

      function renderPosts(posts) {
        postsEl.innerHTML = '';
        posts.forEach((p, idx) => {
          const div = document.createElement('div');
          div.className = 'post';
          div.setAttribute('data-file', p.file_path || '');
          div.innerHTML = `
            <div class="title">${escapeHtml(p.title || '(no title)')}</div>
            <div class="meta">${escapeHtml(p.subreddit || '')}</div>
            <div class="self">${escapeHtml(p.self_text || '')}</div>
            <div class="row" style="margin-top:8px">
              <label><input type="checkbox" class="adh" data-index="${idx}"> Adherence</label>
              <label><input type="checkbox" class="coh" data-index="${idx}"> Coherence</label>
            </div>
          `;
          const key = makeKey(p.file_path, p.local_index);
          // initialize default state if unseen
          if (!stateByPost.has(key)) {
            stateByPost.set(key, { adh: false, coh: false, file: p.file_path });
          }
          // set checkbox states from memory
          const adhCb = div.querySelector('input.adh');
          const cohCb = div.querySelector('input.coh');
          const st = stateByPost.get(key);
          adhCb.checked = !!st.adh;
          cohCb.checked = !!st.coh;
          // attach listeners that update memory first
          adhCb.addEventListener('change', async () => {
            const cur = stateByPost.get(key) || { adh: false, coh: false, file: p.file_path };
            cur.adh = adhCb.checked;
            cur.file = p.file_path;
            stateByPost.set(key, cur);
            await computeAndSave();
          });
          cohCb.addEventListener('change', async () => {
            const cur = stateByPost.get(key) || { adh: false, coh: false, file: p.file_path };
            cur.coh = cohCb.checked;
            cur.file = p.file_path;
            stateByPost.set(key, cur);
            await computeAndSave();
          });
          postsEl.appendChild(div);
        });
        // Initialize percentages
        computeAndSave();
      }

      function getBatchPosts(index) {
        const start = index * BATCH_SIZE;
        const end = start + BATCH_SIZE;
        return currentMixed.slice(start, end);
      }

      async function showBatch(index) {
        const batch = getBatchPosts(index);
        renderPosts(batch);
        await sendShownCountsForBatch(batch);
        // Disable next if at end
        const nextBtn = document.getElementById('nextBatch');
        const moreRemain = (index + 1) * BATCH_SIZE < currentMixed.length;
        nextBtn.disabled = !moreRemain;
      }

      async function sendShownCountsForBatch(batch) {
        const fileCounts = {};
        const newlyShown = [];
        batch.forEach(p => {
          const key = makeKey(p.file_path, p.local_index);
          if (!key) return;
          if (shownKeys.has(key)) return; // already counted
          newlyShown.push(key);
          const fp = p.file_path;
          if (!fp) return;
          fileCounts[fp] = (fileCounts[fp] || 0) + 1;
        });
        if (Object.keys(fileCounts).length === 0) return;
        try {
          const resp = await fetch('/judgement/api/shown', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file_counts: fileCounts }),
          });
          const resj = await resp.json().catch(() => ({}));
          // Only mark as shown once successfully sent
          if (resj && resj.ok) {
            newlyShown.forEach(k => shownKeys.add(k));
          }
        } catch (e) {
          console.error('Failed to record shown counts', e);
        }
      }

      function computeCounts() {
        const total = postsEl.querySelectorAll('.post').length;
        const adhChecked = postsEl.querySelectorAll('input.adh:checked').length;
        const cohChecked = postsEl.querySelectorAll('input.coh:checked').length;
        adhPctEl.textContent = String(adhChecked);
        cohPctEl.textContent = String(cohChecked);
        return { adh_count: adhChecked, coh_count: cohChecked, total };
      }

      async function savePercents() {
        if (!currentMixed || currentMixed.length === 0) return;
        const { adh_count, coh_count } = computeCounts();
        // Group by originating file for CURRENTLY RENDERED batch
        const byFile = new Map();
        // Aggregate across ALL seen posts in current selection
        stateByPost.forEach((st, key) => {
          const file = st.file || '';
          if (!file) return;
          if (!byFile.has(file)) byFile.set(file, { adh: 0, coh: 0 });
          const rec = byFile.get(file);
          if (st.adh) rec.adh += 1;
          if (st.coh) rec.coh += 1;
        });
        let allOk = true;
        for (const [file, rec] of byFile.entries()) {
          const payload = {
            file_path: file,
            adh_count: rec.adh,
            coh_count: rec.coh,
          };
          const res = await fetch(API_UPDATE, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          const data = await res.json();
          if (!data.ok) allOk = false;
        }
        statusEl.textContent = allOk ? 'Saved' : 'Save failed';
      }

      async function computeAndSave() {
        computeCounts();
        await savePercents();
      }
      document.getElementById('loadMixed').addEventListener('click', loadMixed);
      document.getElementById('nextBatch').addEventListener('click', async () => {
        pageIndex += 1;
        await showBatch(pageIndex);
      });
      document.getElementById('prevBatch').addEventListener('click', async () => {
        if (pageIndex > 0) {
          pageIndex -= 1;
          await showBatch(pageIndex);
        }
      });

      // Saving happens automatically on checkbox changes

      (async function init() {
        await loadFiles();
        await loadOptions();
      })();
    </script>
  </body>
  </html>
